#include "minishell.h"

void	exec(int cmd)
{
	char	*argv[] = {"ls", NULL};
	char	*argv2[] = {"rev", NULL};
	if (cmd == 0)
		execvp("ls", argv);
	if (cmd == 1)
		execvp("rev", argv2);
}

void	configure_io(int *pipefd, int i)
{	
	if (i == 0)
	{
		dup2(pipefd[1], STDOUT_FILENO);
		close(pipefd[1]);
	}
	if (i == 1)
	{
		dup2(pipefd[0], STDIN_FILENO);
		close(pipefd[0]);
	}
}

int	count_tokens(t_token **tokenlist)
{
	int	count;
	t_token	*tmp;

	count = 0;
	tmp = *tokenlist;
	while (tmp)
	{
		count++;
		tmp = tmp->next;
	}
	return (count);
}

char	**split_tokens_into_array(t_token **tokenlist)
{
	t_token	*tmp;
	char	**array;
	int	i;

	array = malloc(sizeof(char **) * (count_tokens(tokenlist) + 1));
	tmp = *tokenlist;
	i = 0;
	while (tmp)
	{
		array[i] = ft_strdup(tmp->element);
		i++;
		tmp = tmp->next;
	}
	array[i] = 0;
	return(array);
}

void	print_darray(char **darray)
{
	printf("DARR\n");
	while (*darray)
	{
		printf("DARR %s\n", *darray);
		darray++;
	}
	printf("\n\n");
}


char	**cut_arrays_into_expression(char **array, int index)
{
	int	i;	
	int	exp_count;
	char	**expression;

	i = 0;
	exp_count = 0;
	while (*array && ft_strcmp(*array, "|") && exp_count < index)
	{
		if (ft_strcmp(*array, "|") == 0)
			exp_count++;
		array++;
	}
	if (index > 0)
		array++;
	while (array[i] && ft_strcmp(array[i], "|"))
		i++;
	expression = malloc(sizeof(char *) * (i + 1));	
	i = 0;
	while (array[i] && ft_strcmp(array[i], "|"))
	{
		expression[i] = ft_strdup(array[i]);
		i++;
	}
	expression[i] = 0;
	print_darray(expression);
	return (expression);
}

void	close_all_pipes(int **fds, int nb_pipe)
{
	int	i = 0;

	while(i < nb_pipe)
	{
		close(fds[i][0]);
		close(fds[i][1]);
		i++;
	}
}

void	exec_loop(int index, int **fds, int nb_pipe)
{	
	char	*argv[] = {"ls", NULL};
	char	*argv2[] = {"rev", NULL};
	char	*argv3[] = {"cat", NULL};

	if (index == 0)
	{
		int c = fork();
		if (c == 0)
		{
			//In exec child process 1
			dup2(fds[0][1], STDOUT_FILENO);
			close_all_pipes(fds, nb_pipe);
			execvp(*argv, argv);
		}
	}
	else
	{
		int d = fork();
		if (d == 0)
		{
			//In exec child process 2
			dup2(fds[index - 1][0], STDIN_FILENO);
			dup2(fds[index][1], STDOUT_FILENO);
			close_all_pipes(fds, nb_pipe);
			execvp(*argv2, argv2);
		}
	}
	if (index == nb_pipe)
	{
		{
			dup2(fds[1][0], STDIN_FILENO);
			close_all_pipes(fds, nb_pipe);
			execvp(*argv3, argv3);
		}
	}
}

int	**init_pipes(t_data **data)
{
	int	**fds;
	int	i;

	printf("NB PIPES =%d\n", (*data)->nb_pipe);
	fds = malloc(sizeof(int *) * (*data)->nb_pipe);
	i = 0;
	while (i < (*data)->nb_pipe)
	{
		fds[i] = malloc(sizeof(int) * 2);
		pipe(fds[i]);
		i++;
	}
	return (fds);
}

void	execute_line(t_token **tokenlist, t_data **data)
{
	(void)tokenlist;
	int	i;
	int	**fds;
	char	**argv;
	char	**expression;
	
	fds = init_pipes(data);
	argv = split_tokens_into_array(tokenlist);
	int f = fork();
	i = 0;
	if (f == 0)
	{
		while (i <= (*data)->nb_pipe)
		{
			exec_loop(i, fds, (*data)->nb_pipe);	
			i++;
		}
	}
	else
	{
		printf("End of execute line in main process\n");
	}
	close_all_pipes(fds, (*data)->nb_pipe);
	while(wait(NULL) > 0);
	(*data)->nb_pipe = 0;
}
			execve(bin_path, &argv[index] , env_list_to_array((*data)->env));
